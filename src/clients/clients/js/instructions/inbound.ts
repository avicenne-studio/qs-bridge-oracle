/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from "@solana/kit";
import { QS_BRIDGE_PROGRAM_ADDRESS } from "../programs/index.js";
import { getAccountMetaFactory, type ResolvedAccount } from "../shared/index.js";
import {
  getOrderDataDecoder,
  getOrderDataEncoder,
  type OrderData,
  type OrderDataArgs,
} from "../types/index.js";

export const INBOUND_DISCRIMINATOR = 9;

export function getInboundDiscriminatorBytes() {
  return getU8Encoder().encode(INBOUND_DISCRIMINATOR);
}

export type InboundInstruction<
  TProgram extends string = typeof QS_BRIDGE_PROGRAM_ADDRESS,
  TAccountRelayer extends string | AccountMeta<string> = string,
  TAccountGlobalState extends string | AccountMeta<string> = string,
  TAccountTokenMint extends string | AccountMeta<string> = string,
  TAccountRecipient extends string | AccountMeta<string> = string,
  TAccountRecipientAta extends string | AccountMeta<string> = string,
  TAccountRelayerAta extends string | AccountMeta<string> = string,
  TAccountInboundOrderPda extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends string | AccountMeta<string> =
    "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
  TAccountSystemProgram extends string | AccountMeta<string> =
    "11111111111111111111111111111111",
  TAccountAssociatedTokenProgram extends string | AccountMeta<string> = string,
  TAccountOracle1Pda extends string | AccountMeta<string> = string,
  TAccountOracle2Pda extends string | AccountMeta<string> = string,
  TAccountOracle3Pda extends string | AccountMeta<string> = string,
  TAccountOracle4Pda extends string | AccountMeta<string> = string,
  TAccountOracle5Pda extends string | AccountMeta<string> = string,
  TAccountOracle6Pda extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountRelayer extends string
        ? WritableSignerAccount<TAccountRelayer> &
            AccountSignerMeta<TAccountRelayer>
        : TAccountRelayer,
      TAccountGlobalState extends string
        ? WritableAccount<TAccountGlobalState>
        : TAccountGlobalState,
      TAccountTokenMint extends string
        ? WritableAccount<TAccountTokenMint>
        : TAccountTokenMint,
      TAccountRecipient extends string
        ? ReadonlyAccount<TAccountRecipient>
        : TAccountRecipient,
      TAccountRecipientAta extends string
        ? WritableAccount<TAccountRecipientAta>
        : TAccountRecipientAta,
      TAccountRelayerAta extends string
        ? WritableAccount<TAccountRelayerAta>
        : TAccountRelayerAta,
      TAccountInboundOrderPda extends string
        ? WritableAccount<TAccountInboundOrderPda>
        : TAccountInboundOrderPda,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountAssociatedTokenProgram extends string
        ? ReadonlyAccount<TAccountAssociatedTokenProgram>
        : TAccountAssociatedTokenProgram,
      TAccountOracle1Pda extends string
        ? WritableAccount<TAccountOracle1Pda>
        : TAccountOracle1Pda,
      TAccountOracle2Pda extends string
        ? WritableAccount<TAccountOracle2Pda>
        : TAccountOracle2Pda,
      TAccountOracle3Pda extends string
        ? WritableAccount<TAccountOracle3Pda>
        : TAccountOracle3Pda,
      TAccountOracle4Pda extends string
        ? WritableAccount<TAccountOracle4Pda>
        : TAccountOracle4Pda,
      TAccountOracle5Pda extends string
        ? WritableAccount<TAccountOracle5Pda>
        : TAccountOracle5Pda,
      TAccountOracle6Pda extends string
        ? WritableAccount<TAccountOracle6Pda>
        : TAccountOracle6Pda,
      ...TRemainingAccounts,
    ]
  >;

export type InboundInstructionData = {
  discriminator: number;
  order: OrderData;
  signatures: Array<ReadonlyUint8Array>;
};

export type InboundInstructionDataArgs = {
  order: OrderDataArgs;
  signatures: Array<ReadonlyUint8Array>;
};

export function getInboundInstructionDataEncoder(): Encoder<InboundInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", getU8Encoder()],
      ["order", getOrderDataEncoder()],
      ["signatures", getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64))],
    ]),
    (value) => ({ ...value, discriminator: INBOUND_DISCRIMINATOR }),
  );
}

export function getInboundInstructionDataDecoder(): Decoder<InboundInstructionData> {
  return getStructDecoder([
    ["discriminator", getU8Decoder()],
    ["order", getOrderDataDecoder()],
    ["signatures", getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64))],
  ]);
}

export function getInboundInstructionDataCodec(): Codec<
  InboundInstructionDataArgs,
  InboundInstructionData
> {
  return combineCodec(
    getInboundInstructionDataEncoder(),
    getInboundInstructionDataDecoder(),
  );
}

export type InboundInput<
  TAccountRelayer extends string = string,
  TAccountGlobalState extends string = string,
  TAccountTokenMint extends string = string,
  TAccountRecipient extends string = string,
  TAccountRecipientAta extends string = string,
  TAccountRelayerAta extends string = string,
  TAccountInboundOrderPda extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountAssociatedTokenProgram extends string = string,
  TAccountOracle1Pda extends string = string,
  TAccountOracle2Pda extends string = string,
  TAccountOracle3Pda extends string = string,
  TAccountOracle4Pda extends string = string,
  TAccountOracle5Pda extends string = string,
  TAccountOracle6Pda extends string = string,
> = {
  /** Relayer */
  relayer: TransactionSigner<TAccountRelayer>;
  /** Global State */
  globalState: Address<TAccountGlobalState>;
  /** Token Mint */
  tokenMint: Address<TAccountTokenMint>;
  /** Recipient */
  recipient: Address<TAccountRecipient>;
  /** Recipient Associated Token Account */
  recipientAta: Address<TAccountRecipientAta>;
  /** Relayer Associated Token Account */
  relayerAta: Address<TAccountRelayerAta>;
  /** InboundOrder PDA */
  inboundOrderPda: Address<TAccountInboundOrderPda>;
  /** Token Program Account */
  tokenProgram?: Address<TAccountTokenProgram>;
  /** System Program Account */
  systemProgram?: Address<TAccountSystemProgram>;
  /** Associated Token Program Account */
  associatedTokenProgram: Address<TAccountAssociatedTokenProgram>;
  /** Oracle 1 PDA */
  oracle1Pda: Address<TAccountOracle1Pda>;
  /** Oracle 2 PDA */
  oracle2Pda: Address<TAccountOracle2Pda>;
  /** Oracle 3 PDA */
  oracle3Pda: Address<TAccountOracle3Pda>;
  /** Oracle 4 PDA */
  oracle4Pda: Address<TAccountOracle4Pda>;
  /** Oracle 5 PDA */
  oracle5Pda: Address<TAccountOracle5Pda>;
  /** Oracle 6 PDA */
  oracle6Pda: Address<TAccountOracle6Pda>;
  order: InboundInstructionDataArgs["order"];
  signatures: InboundInstructionDataArgs["signatures"];
};

export function getInboundInstruction<
  TAccountRelayer extends string,
  TAccountGlobalState extends string,
  TAccountTokenMint extends string,
  TAccountRecipient extends string,
  TAccountRecipientAta extends string,
  TAccountRelayerAta extends string,
  TAccountInboundOrderPda extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TAccountAssociatedTokenProgram extends string,
  TAccountOracle1Pda extends string,
  TAccountOracle2Pda extends string,
  TAccountOracle3Pda extends string,
  TAccountOracle4Pda extends string,
  TAccountOracle5Pda extends string,
  TAccountOracle6Pda extends string,
  TProgramAddress extends Address = typeof QS_BRIDGE_PROGRAM_ADDRESS,
>(
  input: InboundInput<
    TAccountRelayer,
    TAccountGlobalState,
    TAccountTokenMint,
    TAccountRecipient,
    TAccountRecipientAta,
    TAccountRelayerAta,
    TAccountInboundOrderPda,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountAssociatedTokenProgram,
    TAccountOracle1Pda,
    TAccountOracle2Pda,
    TAccountOracle3Pda,
    TAccountOracle4Pda,
    TAccountOracle5Pda,
    TAccountOracle6Pda
  >,
  config?: { programAddress?: TProgramAddress },
): InboundInstruction<
  TProgramAddress,
  TAccountRelayer,
  TAccountGlobalState,
  TAccountTokenMint,
  TAccountRecipient,
  TAccountRecipientAta,
  TAccountRelayerAta,
  TAccountInboundOrderPda,
  TAccountTokenProgram,
  TAccountSystemProgram,
  TAccountAssociatedTokenProgram,
  TAccountOracle1Pda,
  TAccountOracle2Pda,
  TAccountOracle3Pda,
  TAccountOracle4Pda,
  TAccountOracle5Pda,
  TAccountOracle6Pda
> {
  // Program address.
  const programAddress = config?.programAddress ?? QS_BRIDGE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    relayer: { value: input.relayer ?? null, isWritable: true },
    globalState: { value: input.globalState ?? null, isWritable: true },
    tokenMint: { value: input.tokenMint ?? null, isWritable: true },
    recipient: { value: input.recipient ?? null, isWritable: false },
    recipientAta: { value: input.recipientAta ?? null, isWritable: true },
    relayerAta: { value: input.relayerAta ?? null, isWritable: true },
    inboundOrderPda: { value: input.inboundOrderPda ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false,
    },
    oracle1Pda: { value: input.oracle1Pda ?? null, isWritable: true },
    oracle2Pda: { value: input.oracle2Pda ?? null, isWritable: true },
    oracle3Pda: { value: input.oracle3Pda ?? null, isWritable: true },
    oracle4Pda: { value: input.oracle4Pda ?? null, isWritable: true },
    oracle5Pda: { value: input.oracle5Pda ?? null, isWritable: true },
    oracle6Pda: { value: input.oracle6Pda ?? null, isWritable: true },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      "11111111111111111111111111111111" as Address<"11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.relayer),
      getAccountMeta(accounts.globalState),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.recipient),
      getAccountMeta(accounts.recipientAta),
      getAccountMeta(accounts.relayerAta),
      getAccountMeta(accounts.inboundOrderPda),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.oracle1Pda),
      getAccountMeta(accounts.oracle2Pda),
      getAccountMeta(accounts.oracle3Pda),
      getAccountMeta(accounts.oracle4Pda),
      getAccountMeta(accounts.oracle5Pda),
      getAccountMeta(accounts.oracle6Pda),
    ],
    data: getInboundInstructionDataEncoder().encode(
      args as InboundInstructionDataArgs,
    ),
    programAddress,
  } as InboundInstruction<
    TProgramAddress,
    TAccountRelayer,
    TAccountGlobalState,
    TAccountTokenMint,
    TAccountRecipient,
    TAccountRecipientAta,
    TAccountRelayerAta,
    TAccountInboundOrderPda,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountAssociatedTokenProgram,
    TAccountOracle1Pda,
    TAccountOracle2Pda,
    TAccountOracle3Pda,
    TAccountOracle4Pda,
    TAccountOracle5Pda,
    TAccountOracle6Pda
  >);
}

export type ParsedInboundInstruction<
  TProgram extends string = typeof QS_BRIDGE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** Relayer */
    relayer: TAccountMetas[0];
    /** Global State */
    globalState: TAccountMetas[1];
    /** Token Mint */
    tokenMint: TAccountMetas[2];
    /** Recipient */
    recipient: TAccountMetas[3];
    /** Recipient Associated Token Account */
    recipientAta: TAccountMetas[4];
    /** Relayer Associated Token Account */
    relayerAta: TAccountMetas[5];
    /** InboundOrder PDA */
    inboundOrderPda: TAccountMetas[6];
    /** Token Program Account */
    tokenProgram: TAccountMetas[7];
    /** System Program Account */
    systemProgram: TAccountMetas[8];
    /** Associated Token Program Account */
    associatedTokenProgram: TAccountMetas[9];
    /** Oracle 1 PDA */
    oracle1Pda: TAccountMetas[10];
    /** Oracle 2 PDA */
    oracle2Pda: TAccountMetas[11];
    /** Oracle 3 PDA */
    oracle3Pda: TAccountMetas[12];
    /** Oracle 4 PDA */
    oracle4Pda: TAccountMetas[13];
    /** Oracle 5 PDA */
    oracle5Pda: TAccountMetas[14];
    /** Oracle 6 PDA */
    oracle6Pda: TAccountMetas[15];
  };
  data: InboundInstructionData;
};

export function parseInboundInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedInboundInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 16) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      relayer: getNextAccount(),
      globalState: getNextAccount(),
      tokenMint: getNextAccount(),
      recipient: getNextAccount(),
      recipientAta: getNextAccount(),
      relayerAta: getNextAccount(),
      inboundOrderPda: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      oracle1Pda: getNextAccount(),
      oracle2Pda: getNextAccount(),
      oracle3Pda: getNextAccount(),
      oracle4Pda: getNextAccount(),
      oracle5Pda: getNextAccount(),
      oracle6Pda: getNextAccount(),
    },
    data: getInboundInstructionDataDecoder().decode(instruction.data),
  };
}

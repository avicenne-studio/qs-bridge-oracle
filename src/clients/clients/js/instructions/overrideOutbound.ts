/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from "@solana/kit";
import { QS_BRIDGE_PROGRAM_ADDRESS } from "../programs/index.js";
import { getAccountMetaFactory, type ResolvedAccount } from "../shared/index.js";

export const OVERRIDE_OUTBOUND_DISCRIMINATOR = 2;

export function getOverrideOutboundDiscriminatorBytes() {
  return getU8Encoder().encode(OVERRIDE_OUTBOUND_DISCRIMINATOR);
}

export type OverrideOutboundInstruction<
  TProgram extends string = typeof QS_BRIDGE_PROGRAM_ADDRESS,
  TAccountCaller extends string | AccountMeta<string> = string,
  TAccountGlobalState extends string | AccountMeta<string> = string,
  TAccountOutboundOrder extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountCaller extends string
        ? WritableSignerAccount<TAccountCaller> &
            AccountSignerMeta<TAccountCaller>
        : TAccountCaller,
      TAccountGlobalState extends string
        ? ReadonlyAccount<TAccountGlobalState>
        : TAccountGlobalState,
      TAccountOutboundOrder extends string
        ? WritableAccount<TAccountOutboundOrder>
        : TAccountOutboundOrder,
      ...TRemainingAccounts,
    ]
  >;

export type OverrideOutboundInstructionData = {
  discriminator: number;
  toAddress: Option<ReadonlyUint8Array>;
  relayerFee: Option<bigint>;
};

export type OverrideOutboundInstructionDataArgs = {
  toAddress: OptionOrNullable<ReadonlyUint8Array>;
  relayerFee: OptionOrNullable<number | bigint>;
};

export function getOverrideOutboundInstructionDataEncoder(): Encoder<OverrideOutboundInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", getU8Encoder()],
      ["toAddress", getOptionEncoder(fixEncoderSize(getBytesEncoder(), 32))],
      ["relayerFee", getOptionEncoder(getU64Encoder())],
    ]),
    (value) => ({ ...value, discriminator: OVERRIDE_OUTBOUND_DISCRIMINATOR }),
  );
}

export function getOverrideOutboundInstructionDataDecoder(): Decoder<OverrideOutboundInstructionData> {
  return getStructDecoder([
    ["discriminator", getU8Decoder()],
    ["toAddress", getOptionDecoder(fixDecoderSize(getBytesDecoder(), 32))],
    ["relayerFee", getOptionDecoder(getU64Decoder())],
  ]);
}

export function getOverrideOutboundInstructionDataCodec(): Codec<
  OverrideOutboundInstructionDataArgs,
  OverrideOutboundInstructionData
> {
  return combineCodec(
    getOverrideOutboundInstructionDataEncoder(),
    getOverrideOutboundInstructionDataDecoder(),
  );
}

export type OverrideOutboundInput<
  TAccountCaller extends string = string,
  TAccountGlobalState extends string = string,
  TAccountOutboundOrder extends string = string,
> = {
  /** Caller who owns the order */
  caller: TransactionSigner<TAccountCaller>;
  /** Global State */
  globalState: Address<TAccountGlobalState>;
  /** Outbound Order PDA */
  outboundOrder: Address<TAccountOutboundOrder>;
  toAddress: OverrideOutboundInstructionDataArgs["toAddress"];
  relayerFee: OverrideOutboundInstructionDataArgs["relayerFee"];
};

export function getOverrideOutboundInstruction<
  TAccountCaller extends string,
  TAccountGlobalState extends string,
  TAccountOutboundOrder extends string,
  TProgramAddress extends Address = typeof QS_BRIDGE_PROGRAM_ADDRESS,
>(
  input: OverrideOutboundInput<
    TAccountCaller,
    TAccountGlobalState,
    TAccountOutboundOrder
  >,
  config?: { programAddress?: TProgramAddress },
): OverrideOutboundInstruction<
  TProgramAddress,
  TAccountCaller,
  TAccountGlobalState,
  TAccountOutboundOrder
> {
  // Program address.
  const programAddress = config?.programAddress ?? QS_BRIDGE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    caller: { value: input.caller ?? null, isWritable: true },
    globalState: { value: input.globalState ?? null, isWritable: false },
    outboundOrder: { value: input.outboundOrder ?? null, isWritable: true },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.caller),
      getAccountMeta(accounts.globalState),
      getAccountMeta(accounts.outboundOrder),
    ],
    data: getOverrideOutboundInstructionDataEncoder().encode(
      args as OverrideOutboundInstructionDataArgs,
    ),
    programAddress,
  } as OverrideOutboundInstruction<
    TProgramAddress,
    TAccountCaller,
    TAccountGlobalState,
    TAccountOutboundOrder
  >);
}

export type ParsedOverrideOutboundInstruction<
  TProgram extends string = typeof QS_BRIDGE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** Caller who owns the order */
    caller: TAccountMetas[0];
    /** Global State */
    globalState: TAccountMetas[1];
    /** Outbound Order PDA */
    outboundOrder: TAccountMetas[2];
  };
  data: OverrideOutboundInstructionData;
};

export function parseOverrideOutboundInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedOverrideOutboundInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 3) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      caller: getNextAccount(),
      globalState: getNextAccount(),
      outboundOrder: getNextAccount(),
    },
    data: getOverrideOutboundInstructionDataDecoder().decode(instruction.data),
  };
}

# Oracle Developer Guide - Qubic-Solana Bridge

This guide is for Oracle developers (guardian-relayers) who need to interact with the Solana smart contract from a Node.js server.

## Table of Contents
1. [What is Codama?](#what-is-codama)
2. [Relevant Scripts](#relevant-scripts)
3. [Interacting from Node.js](#interacting-from-nodejs)
4. [PR Review Checklist](#pr-review-checklist)

---

## What is Codama?

**Codama** is a code generation tool that automatically generates TypeScript/JavaScript client code from the Solana program's IDL (Interface Definition Language). It's similar to how Anchor generates clients, but uses a different approach.

### Configuration in This Project

The Codama configuration is in `codama.json`:

```json
{
  "idl": "idl/qs_bridge.json",
  "before": ["./scripts/codama.before.cjs"],
  "scripts": {
    "js": {
      "from": "@codama/renderers-js",
      "args": ["src/clients/js"]
    }
  }
}
```

**What this means:**
- **`idl`**: Points to the IDL file that describes the program interface
- **`before`**: Runs a script before code generation to add custom features (like PDA helpers)
- **`scripts.js`**: Generates JavaScript/TypeScript client code in `src/clients/js/`

### The `before` Script

The `scripts/codama.before.cjs` file adds Program Derived Address (PDA) helpers for:
- `globalState` - The global state account
- `oracle` - Oracle accounts (one per oracle public key)
- `pauser` - Pauser accounts

**Important**: The generated code in `src/clients/js/` is **AUTOGENERATED**. Do not edit it directly. If you need changes, modify the IDL or the `before` script, then regenerate.

### Regenerating Client Code

If the Solana program changes, regenerate the client code:

```bash
npm run idl:codama
```

Or to regenerate both the IDL and client code:

```bash
npm run idl:all
```

---

## Relevant Scripts

### Available NPM Scripts

From `package.json`:

- **`npm run idl:shank`** - Generates the IDL from Rust code using Shank
- **`npm run idl:codama`** - Generates TypeScript client code from IDL using Codama
- **`npm run idl:all`** - Runs both IDL generation steps
- **`npm test`** - Builds the program and runs tests
- **`npm run test:watch`** - Runs tests in watch mode

### For Oracle Developers

You typically **don't need to run these scripts** unless:
1. The contract has been updated and you need the latest client code
2. You're contributing to the contract itself

**What you need**: The generated code in `src/clients/js/` directory, which should already be committed to the repository.

---

## Interacting from Node.js

### Installation

The client code requires these dependencies. **These need to be installed** as they are not currently in `package.json`:

```bash
npm install @solana/kit @solana/web3.js @solana-program/system @solana-program/token
```

**Note:** The `@solana/kit` package is the primary dependency used throughout the generated client code for encoding/decoding, PDA derivation, and account fetching.

### Program Address

The program address is exported from the client:

```typescript
import { QS_BRIDGE_PROGRAM_ADDRESS } from './src/clients/js/programs/qsBridge';
// Value: "qSBGtee9tspoDVmb867Wq6tcR3kp19XN1PbBVckrH7H"
```

### Key Concepts for Oracle Operations

As an Oracle, you primarily need to:

1. **Listen for Outbound events** - When users lock tokens to bridge to Qubic
2. **Read OutboundOrder accounts** - To get order details
3. **Verify Oracle status** - Check if your oracle is registered

### 1. Finding PDAs (Program Derived Addresses)

#### Global State PDA

```typescript
import { findGlobalStatePda } from './src/clients/js/pdas/globalState';

const [globalStatePda] = await findGlobalStatePda();
```

#### Oracle PDA

```typescript
import { findOraclePda } from './src/clients/js/pdas/oracle';
import { PublicKey } from '@solana/web3.js';

const oraclePubkey = new PublicKey('YOUR_ORACLE_PUBLIC_KEY');
const [oraclePda] = await findOraclePda({ 
  oracle: oraclePubkey.toString() 
});
```

#### Outbound Order PDA

Outbound orders are derived from:
- `"outbound_order"` (seed string)
- `networkOut` (u32)
- `nonce` (32 bytes)

```typescript
import { findOutboundOrderPda } from './src/clients/js/pdas/outboundOrder';

const networkOut = 1; // Qubic network ID
const nonce = new Uint8Array(32); // The nonce from the outbound event

const [outboundOrderPda] = await findOutboundOrderPda({
  networkOut,
  nonce,
});
```

#### Inbound Order PDA

Inbound orders are derived from:
- `"inbound_order"` (seed string)
- `networkIn` (u32)
- `nonce` (32 bytes)

```typescript
import { findInboundOrderPda } from './src/clients/js/pdas/inboundOrder';

const networkIn = 1; // Qubic network ID
const nonce = new Uint8Array(32); // The nonce from the inbound event

const [inboundOrderPda] = await findInboundOrderPda({
  networkIn,
  nonce,
});
```

### 2. Reading Account Data

#### Fetch Global State

```typescript
import { fetchGlobalState } from './src/clients/js/accounts/globalState';
import { Connection } from '@solana/web3.js';

const connection = new Connection('https://api.mainnet-beta.solana.com');
const [globalStatePda] = await findGlobalStatePda();

const globalState = await fetchGlobalState(connection, globalStatePda);

console.log({
  admin: globalState.data.admin,
  paused: globalState.data.paused,
  oracleCount: globalState.data.oracleCount,
  oracleThresholdPercent: globalState.data.oracleThresholdPercent,
  tokenMint: globalState.data.tokenMint,
});
```

#### Fetch Oracle Account

```typescript
import { fetchOracle } from './src/clients/js/accounts/oracle';

const [oraclePda] = await findOraclePda({ oracle: oraclePubkey.toString() });
const oracle = await fetchOracle(connection, oraclePda);

console.log({
  oraclePubkey: oracle.data.oraclePubkey,
  bump: oracle.data.bump,
});
```

#### Fetch Outbound Order

```typescript
import { fetchOutboundOrder } from './src/clients/js/accounts/outboundOrder';

const outboundOrder = await fetchOutboundOrder(connection, outboundOrderPda);

console.log({
  networkIn: outboundOrder.data.networkIn, // Should be 2 (Solana)
  networkOut: outboundOrder.data.networkOut, // Should be 1 (Qubic)
  tokenIn: outboundOrder.data.tokenIn, // Solana token mint
  tokenOut: outboundOrder.data.tokenOut, // Qubic contract address
  fromAddress: outboundOrder.data.fromAddress, // User's Solana address
  toAddress: outboundOrder.data.toAddress, // Destination Qubic address
  amount: outboundOrder.data.amount,
  relayerFee: outboundOrder.data.relayerFee,
  nonce: outboundOrder.data.nonce,
});
```

#### Fetch Inbound Order

```typescript
import { fetchInboundOrder } from './src/clients/js/accounts/inboundOrder';

const inboundOrder = await fetchInboundOrder(connection, inboundOrderPda);

console.log({
  key: inboundOrder.data.key,
  networkIn: inboundOrder.data.networkIn, // Should be 1 (Qubic)
  nonce: inboundOrder.data.nonce,
  bump: inboundOrder.data.bump,
});
```

### 3. Listening to Events

The contract emits events when orders are created or modified. You can listen to these via Solana transaction logs.

#### Event Types

The contract emits three types of events:

1. **OutboundEvent** - Emitted when a user locks tokens to bridge to Qubic
2. **OverrideOutboundEvent** - Emitted when a user updates their outbound order (toAddress and relayerFee)
3. **InboundEvent** - Emitted when tokens are bridged from Qubic to Solana

#### OutboundEvent Structure

```typescript
import { getOutboundEventDecoder } from './src/clients/js/types/outboundEvent';

// Event type:
type OutboundEvent = {
  networkIn: number;      // 2 = Solana
  networkOut: number;     // 1 = Qubic
  tokenIn: Uint8Array;    // 32 bytes - Solana token mint
  tokenOut: Uint8Array;   // 32 bytes - Qubic contract address
  fromAddress: Uint8Array; // 32 bytes - User's Solana address
  toAddress: Uint8Array;    // 32 bytes - Destination Qubic address
  amount: bigint;
  relayerFee: bigint;
  nonce: Uint8Array;      // 32 bytes
};
```

#### OverrideOutboundEvent Structure

```typescript
import { getOverrideOutboundEventDecoder } from './src/clients/js/types/overrideOutboundEvent';

// Event type:
type OverrideOutboundEvent = {
  toAddress: Uint8Array;    // 32 bytes - Updated destination Qubic address
  relayerFee: bigint;       // Updated relayer fee
  nonce: Uint8Array;        // 32 bytes - Order nonce (to identify which order was updated)
};
```

#### InboundEvent Structure

```typescript
import { getInboundEventDecoder } from './src/clients/js/types/inboundEvent';

// Event type:
type InboundEvent = {
  networkIn: number;      // 1 = Qubic
  networkOut: number;     // 2 = Solana
  tokenIn: Uint8Array;    // 32 bytes - Qubic contract address
  tokenOut: Uint8Array;   // 32 bytes - Solana token mint
  fromAddress: Uint8Array; // 32 bytes - Source Qubic address
  toAddress: Uint8Array;    // 32 bytes - Destination Solana address
  amount: bigint;
  relayerFee: bigint;
  nonce: Uint8Array;      // 32 bytes
};
```

#### Listening via WebSocket

```typescript
import { Connection, PublicKey } from '@solana/web3.js';
import { QS_BRIDGE_PROGRAM_ADDRESS } from './src/clients/js/programs/qsBridge';
import { getOutboundEventDecoder } from './src/clients/js/types/outboundEvent';

const connection = new Connection('wss://api.mainnet-beta.solana.com');
const programId = new PublicKey(QS_BRIDGE_PROGRAM_ADDRESS);

// Subscribe to program account changes
const subscriptionId = connection.onProgramAccountChange(
  programId,
  async (accountInfo, context) => {
    // Parse logs to find events
    // Events are emitted as base64-encoded data in logs
    // Look for logs starting with "Program data:"
  },
  'confirmed'
);
```

#### Parsing Events from Transaction Logs

Based on the test files, events are emitted in logs with format `"Program data: <base64>"`:

**Parsing OutboundEvent:**

```typescript
import { getOutboundEventDecoder } from './src/clients/js/types/outboundEvent';

// After getting transaction logs
const logs = transactionResponse.meta?.logMessages || [];
const eventLog = logs.find((log) => log.startsWith("Program data:"));

if (eventLog) {
  const base64Data = eventLog.split("Program data: ")[1];
  const eventBytes = new Uint8Array(Buffer.from(base64Data, "base64"));
  const decodedEvent = getOutboundEventDecoder().decode(eventBytes);
  
  console.log('Outbound event:', {
    networkIn: decodedEvent.networkIn,
    networkOut: decodedEvent.networkOut,
    amount: decodedEvent.amount.toString(),
    relayerFee: decodedEvent.relayerFee.toString(),
    nonce: Array.from(decodedEvent.nonce),
    toAddress: Array.from(decodedEvent.toAddress),
  });
}
```

**Parsing OverrideOutboundEvent:**

```typescript
import { getOverrideOutboundEventDecoder } from './src/clients/js/types/overrideOutboundEvent';

// After getting transaction logs
const logs = transactionResponse.meta?.logMessages || [];
const eventLog = logs.find((log) => log.startsWith("Program data:"));

if (eventLog) {
  const base64Data = eventLog.split("Program data: ")[1];
  const eventBytes = new Uint8Array(Buffer.from(base64Data, "base64"));
  const decodedEvent = getOverrideOutboundEventDecoder().decode(eventBytes);
  
  console.log('Override outbound event:', {
    toAddress: Array.from(decodedEvent.toAddress),
    relayerFee: decodedEvent.relayerFee.toString(),
    nonce: Array.from(decodedEvent.nonce),
  });
}
```

**Parsing InboundEvent:**

```typescript
import { getInboundEventDecoder } from './src/clients/js/types/inboundEvent';

// After getting transaction logs
const logs = transactionResponse.meta?.logMessages || [];
const eventLog = logs.find((log) => log.startsWith("Program data:"));

if (eventLog) {
  const base64Data = eventLog.split("Program data: ")[1];
  const eventBytes = new Uint8Array(Buffer.from(base64Data, "base64"));
  const decodedEvent = getInboundEventDecoder().decode(eventBytes);
  
  console.log('Inbound event:', {
    networkIn: decodedEvent.networkIn,
    networkOut: decodedEvent.networkOut,
    amount: decodedEvent.amount.toString(),
    relayerFee: decodedEvent.relayerFee.toString(),
    nonce: Array.from(decodedEvent.nonce),
    toAddress: Array.from(decodedEvent.toAddress),
  });
}
```

### 4. Available Instructions (For Reference)

The contract exposes these instructions (you typically won't call these as an Oracle):

- `initGlobalState` - Initialize the bridge (admin only)
- `outbound` - User locks tokens to bridge out
- `overrideOutbound` - User can update `toAddress` and `relayerFee` of their order
- `addOracle` / `removeOracle` - Manage oracles (admin only)
- `addPauser` / `removePauser` - Manage pausers (admin only)
- `pause` / `unpause` - Pause/unpause the bridge (pauser only)
- `claimProtocolFee` - Claim accumulated protocol fees (protocol fee recipient only)

### 5. Example: Complete Oracle Workflow

```typescript
import { Connection, PublicKey } from '@solana/web3.js';
import { 
  findGlobalStatePda, 
  fetchGlobalState 
} from './src/clients/js';
import { 
  findOraclePda, 
  fetchOracle 
} from './src/clients/js';
import { QS_BRIDGE_PROGRAM_ADDRESS } from './src/clients/js/programs/qsBridge';

async function checkOracleStatus(oraclePubkey: PublicKey) {
  const connection = new Connection('https://api.mainnet-beta.solana.com');
  
  // 1. Check if bridge is paused
  const [globalStatePda] = await findGlobalStatePda();
  const globalState = await fetchGlobalState(connection, globalStatePda);
  
  if (globalState.data.paused) {
    throw new Error('Bridge is paused');
  }
  
  // 2. Check if oracle is registered
  const [oraclePda] = await findOraclePda({ 
    oracle: oraclePubkey.toString() 
  });
  
  try {
    const oracle = await fetchOracle(connection, oraclePda);
    console.log('Oracle is registered:', oracle.data.oraclePubkey);
    return true;
  } catch (error) {
    console.log('Oracle is not registered');
    return false;
  }
}

async function processOutboundOrder(nonce: Uint8Array, networkOut: number) {
  const connection = new Connection('https://api.mainnet-beta.solana.com');
  
  // Derive outbound order PDA
  const [outboundOrderPda] = await getProgramDerivedAddress({
    programAddress: QS_BRIDGE_PROGRAM_ADDRESS,
    seeds: [
      getUtf8Encoder().encode("outbound_order"),
      getU32Encoder().encode(networkOut),
      getBytesEncoder().encode(nonce),
    ],
  });
  
  // Fetch order details
  const order = await fetchOutboundOrder(connection, outboundOrderPda);
  
  // Process the order (your logic here)
  console.log('Processing order:', {
    amount: order.data.amount.toString(),
    toAddress: Buffer.from(order.data.toAddress).toString('hex'),
    relayerFee: order.data.relayerFee.toString(),
  });
}
```

---

## PR Review Checklist

When reviewing this PR as an Oracle developer, focus on:

### 1. Contract Interface Changes

- [ ] **Check IDL changes** (`idl/qs_bridge.json`)
  - Are there new instructions that affect Oracle operations?
  - Have existing instruction parameters changed?
  - Are there new account types or event types?

### 2. Client Code Generation

- [ ] **Verify client code is up-to-date**
  - Check if `src/clients/js/` files have been regenerated after contract changes
  - Look for any manual edits in generated files (should be none)

### 3. Oracle-Related Functionality

- [ ] **Oracle management**
  - How are oracles added/removed?
  - What are the permissions/authorities?
  - Check `tests/oracle.ts` for test coverage

- [ ] **Oracle threshold**
  - What is `oracleThresholdPercent` used for?
  - How does it affect bridge operations?

### 4. Outbound Order Flow

- [ ] **Order creation** (`outbound` instruction)
  - What data is stored in `OutboundOrder`?
  - How is the order PDA derived?
  - Check `tests/outbound.ts` for examples

- [ ] **Order modification** (`overrideOutbound` instruction)
  - What can users modify?
  - Are there restrictions?
  - Check `tests/override_outbound.ts` for examples

### 5. Events and Monitoring

- [ ] **Event emission**
  - What events are emitted?
  - How are they structured?
  - Can you reliably parse them from logs?

- [ ] **Account structure**
  - Are account sizes reasonable?
  - Can you efficiently query orders?

### 6. Security Considerations

- [ ] **Pause mechanism**
  - How does pausing work?
  - Who can pause?
  - What happens to pending orders when paused?

- [ ] **Access control**
  - Who can add/remove oracles?
  - Who can modify global state?
  - Are there any privilege escalation risks?

### 7. Testing

- [ ] **Test coverage**
  - Are all critical paths tested?
  - Do tests match the actual usage patterns?
  - Are edge cases covered?

### 8. Documentation

- [ ] **Code comments**
  - Are complex operations documented?
  - Are PDAs and their seeds clearly explained?

### 9. Breaking Changes

- [ ] **Backward compatibility**
  - Will existing Oracle code break?
  - Are account structures changed?
  - Are event formats changed?

### 10. Integration Points

- [ ] **Your Oracle service**
  - Can you still listen to events the same way?
  - Can you still query orders the same way?
  - Do you need to update your code?

---

## Key Files for Oracle Developers

### Must Understand
- `src/clients/js/accounts/outboundOrder.ts` - Outbound order account structure
- `src/clients/js/accounts/inboundOrder.ts` - Inbound order account structure
- `src/clients/js/accounts/oracle.ts` - Oracle account structure
- `src/clients/js/accounts/globalState.ts` - Global state (includes pause status, oracle count)
- `src/clients/js/types/outboundEvent.ts` - Outbound event structure
- `src/clients/js/types/overrideOutboundEvent.ts` - Override outbound event structure
- `src/clients/js/types/inboundEvent.ts` - Inbound event structure
- `src/clients/js/pdas/` - PDA derivation helpers

### Reference
- `tests/outbound.ts` - Example of creating outbound orders
- `tests/oracle.ts` - Example of oracle management
- `idl/qs_bridge.json` - Full contract interface

### Can Ignore
- `program/` - Rust contract code (unless you need to understand logic)
- `scripts/` - Build/generation scripts (unless regenerating clients)

---

## Quick Reference

### Program Address
```
qSBGtee9tspoDVmb867Wq6tcR3kp19XN1PbBVckrH7H
```

### Network IDs
- Solana: `2`
- Qubic: `1`

### Key Account Sizes
- GlobalState: 105 bytes
- Oracle: 34 bytes
- OutboundOrder: 186 bytes

### PDA Seeds

**Global State:**
- `["global_state"]`

**Oracle:**
- `["oracle", oraclePubkey]`

**Outbound Order:**
- `["outbound_order", networkOut (u32), nonce (32 bytes)]`

**Inbound Order:**
- `["inbound_order", networkIn (u32), nonce (32 bytes)]`

---

## Getting Help

If you encounter issues:

1. Check the test files in `tests/` for usage examples
2. Review the IDL in `idl/qs_bridge.json` for the full interface
3. Check generated client code comments in `src/clients/js/`
4. Ensure you're using the correct program address for your environment (devnet vs mainnet)
